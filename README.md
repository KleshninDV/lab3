[лаб3 отчёт.txt](https://github.com/user-attachments/files/24673896/3.txt)Клешнин Дмитрий ИТ-7 Лабораторная №3

================================================================================================

Задание 1. Инкапсуляция и исключения

Дом над землей. Измените сущность Дом. Гарантируйте, что у дома всегда будет положительное количество этажей. В случае попытки указать отрицательное количество этажей должна выбрасываться соответствующая ошибка. Создание дома может осуществляться только путем указания количества этажей. После создания дому нельзя изменить количество этажей.

Реализован класс House в пакете lab3.zad1.
Поле numberOfFloors объявлено как private final (инкапсуляция + неизменяемость).
В конструкторе добавлена валидация входных данных.
Класс Main организует ввод данных и обработку исключений.

Алгоритм решения:

В классе House поле этажности скрыто (private) и неизменяемо (final).
Конструктор принимает число этажей. Если число <= 0, выбрасывается throw new IllegalArgumentException.
Сеттеры отсутствуют, изменение состояния объекта невозможно.
В Main используется блок try-catch внутри цикла while для безопасного ввода данных пользователем до тех пор, пока не будет введено корректное значение.
Пример работы:
============== ЗАДАНИЕ 1 (Дом) ==============
Создание дома. Введите данные с клавиатуры.
Введите количество этажей (попробуйте <= 0 для проверки ошибки):
Ввод числа: -5
Ошибка валидации: Количество этажей должно быть положительным! Введено: -5
Попробуйте ввести значение еще раз.
Ввод числа: 5
Успех! Создан объект: Дом { этажей: 5 }

================================================================================================

Задание 2. Состояние объекта и логика

Перезарядка Пистолета. Измените сущность Пистолет. Дополнительные требования:
Имеет максимальное количество патронов (устанавливается при создании, неизменяемо).
Может быть перезаряжен (лишние патроны возвращаются).
Может быть разряжен (возврат всех патронов).
Стрельба уменьшает количество патронов ("Бах!" или "Клац!").

Реализован класс Gun в пакете lab3.zad2.
Реализована логика управления боезапасом: currentAmmo и maxAmmo.
Метод reload рассчитывает разницу между текущим и максимальным значением.

Алгоритм решения:

Поле maxAmmo помечено final.
Метод reload(int count): вычисляет needed = maxAmmo - currentAmmo. Если count > needed, заряжает полностью и возвращает остаток.
Метод shoot(): проверяет currentAmmo > 0. Если да — декремент и вывод "Бах!", иначе "Клац!".
Метод discharge(): обнуляет currentAmmo и возвращает старое значение.
Пример работы:
============== ЗАДАНИЕ 2 (Пистолет) ==============
Создание пистолета.
Введите максимальную вместимость магазина:
Ввод числа: 7
Пистолет создан: Пистолет { патроны: 0/7 }
...
Меню: 2. Зарядить патроны
Сколько патронов зарядить?
Ввод числа: 10
Заряжено. Лишних патронов вернулось: 3
Меню: 1. Стрелять
Бах!

================================================================================================

Задание 3. Наследование и полиморфизм

Автомат. Создайте подвид сущности Пистолет. Отличия:
Имеет скорострельность (выстрелов в секунду, неизменяемое).
При вызове Стрелять делает серию выстрелов равную скорострельности.
Умеет Стрелять N секунд (N * скорострельность выстрелов).
Различные варианты инициализации (конструкторы).

Реализован класс MachineGun в пакете lab3.zad3, наследующий Gun.
Переопределен метод shoot(). Добавлен метод shoot(int seconds).
Использован механизм перегрузки конструкторов (this(...)) и вызов конструктора родителя (super(...)).

Алгоритм решения:

Класс MachineGun extends Gun. Добавлено поле final fireRate.
Конструкторы:
Без параметров: вызывает this(30, 30).
Только вместимость: вызывает this(max, max/2).
Полный: вызывает super(max) и инициализирует fireRate.
Переопределение shoot(): цикл от 0 до fireRate, внутри вызов super.shoot().
Метод shoot(seconds): цикл на (seconds * fireRate) и вызов super.shoot().
Пример работы:
============== ЗАДАНИЕ 3 (Автомат) ==============
Выберите способ создания автомата:
...
Ваш выбор способа > 1
Автомат успешно создан: Автомат { скорострельность: 30, состояние: Пистолет { патроны: 0/30 } }

Меню: 3. Зарядить
Сколько зарядить?
Ввод числа: 30
Заряжено. Вернулось лишних: 0

Меню: 1. Одиночный вызов 'Стрелять'
Бах!
Бах!
... (30 раз)
Клац!

================================================================================================

Задание 4. Создание иерархий: abstract

Оружие.
Измените сущность Пистолет таким образом, чтобы она наследовалась от абстрактного класса Weapon. Класс Weapon содержит приватное поле ammo и методы для управления им (getAmmo, load).

Реализован пакет zad4. Абстрактный класс Weapon инкапсулирует логику хранения патронов. Класс Gun наследуется от Weapon.

Алгоритм решения:

Класс Weapon (abstract) содержит private int ammo.
Метод getAmmo() в Weapon возвращает boolean (удалось ли взять патрон) и уменьшает счетчик.
Класс Gun не имеет доступа к ammo напрямую. В методе shoot() он вызывает getAmmo(). В методе discharge() он вынужден вызывать getAmmo() в цикле, пока патроны не кончатся.
Пример работы:
============== ЗАДАНИЕ 4 (Abstract Weapon) ==============
Создание пистолета на базе абстрактного класса.
Введите вместимость:
Ввод числа: 5
Создан: Пистолет (Weapon) { патроны: 0/5 }
...
Проверка метода ammo() из родителя: 0

================================================================================================

Задание 5. Сравнение объектов

Сравнение точек.
Измените сущность Точка. Переопределите метод сравнения объектов по состоянию таким образом, чтобы две точки считались одинаковыми тогда, когда они расположены в одинаковых координатах.

Реализован класс Point в пакете zad5. Переопределен метод equals.

Алгоритм решения:

Метод equals(Object o) проверяет ссылки (this == o).
Проверяет класс объекта и null.
Приводит объект к типу Point и сравнивает примитивные поля x и y.
Это позволяет сравнивать точки по значению, а не по ссылке в памяти.
Пример работы:
============== ЗАДАНИЕ 5 (Сравнение Точек) ==============
Создание Точки 1. X: 3, Y: 5
Создание Точки 2. X: 3, Y: 5
Информация:
Точка 1: {3;5}
Точка 2: {3;5}
Сравнение через equals: true
Результат: Точки равны (находятся в одних координатах).

================================================================================================

Задание 6. Модификаторы доступа (protected)

Патроны наследникам.
Измените класс Weapon из задачи 4 таким образом, чтобы любой класс наследник мог непосредственно работать с полем, хранящим количество патронов. Упростите метод разрядки в классе Gun.

Реализован пакет zad6. В классе Weapon модификатор поля ammo изменен с private на protected.

Алгоритм решения:

Protected дает доступ к полю классам-наследникам.
В классе Gun теперь можно писать this.ammo.
Метод discharge() значительно упрощен: вместо цикла while(getAmmo()) используется прямое присваивание ammo = 0.
Пример работы:
============== ЗАДАНИЕ 6 (Protected Ammo) ==============
В этом задании класс использует поле protected ammo.
...
3. Разрядить
Разряжено. Извлечено: 5
(Операция выполнена через прямой доступ к полю родителя).

================================================================================================





